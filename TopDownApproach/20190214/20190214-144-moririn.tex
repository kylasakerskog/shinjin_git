\documentclass[9pt,a4j,twocolumn]{jsarticle}
\usepackage[dvipdfmx]{graphicx}
\usepackage{ascmac}
\usepackage{txfonts}
\usepackage{float}
\usepackage{cite}

\setlength{\topmargin}{-3cm}
\setlength{\textheight}{29.5cm}
\setlength{\textwidth}{20.0cm}
\setlength{\oddsidemargin}{-0.9cm}
\setlength{\evensidemargin}{-0.9cm}
\setlength{\baselineskip}{0.5cm}
\renewcommand{\baselinestretch}{0.865}

\title{
    Computer Networking\\
    A Top-Down Approach pp.144-169
}
\author{
    %トップダウン・アプローチの作者
    James F. Kurose, Keith W. Roth
    \\\\
    情報工学科3年 寺岡研究室\\
    学籍番号 61619027 名前 安森涼
}
\date{2019年 2月 14日}
\begin{document}
\maketitle

\section{Peer to Peer アプリケーション}
Web, Email, DNSのようにクライアントとサーバの関係にあるものは基盤サーバ側に信頼が必要である．一方でPeer to Peer(P2P)アプリケーションは基盤サーバ側に信頼を必要としない．その代わり，ピアという断続的につながっているホストの組が必要で，これはサービスプロバイダではなく，ユーザのデスクトップやノートパソコン間で提供されるものである．この節では，P2Pによく適している二つの異なるアプリケーションを説明する．一つ目がファイル分配で単一のソースから多くのピアにファイルを送信するものである．この例として，最も一般的なP2Pファイル分配プロトコルであるBitTorrentを紹介する．二つ目が分散データベースで，これは巨大なピアの共同体により配信されるデータベースである．ここでDatabase Hash Tables (DHT)について述べる．
\\
\subsection{ファイル分配}
P2PではLinux OSのアップデート，ソフトウェア，MP3音楽ファイル，MPEGビデオファイルなどの大容量のファイルを単一のサーバから多数のホストに送ることを考える．クライアントサーバ構造でのファイル分配ではサーバがピアに大きなファイルを送る．この際，サーバのチア息を大きく占有してしまうという問題がある．P2P構造のファイル分配ではピア側のどの部分でも再分配できる．そのためサーバの帯域を占有せずにファイルの送信が可能である．WebブラウザがHTTPを形成しているように，BitTorrentがプロトコルを形成している．
\\
\subsubsection{スケーラビリティ}
スケーラビリティとは利用者や仕事の増大に適応できる能力度合いのことである．これを説明するのに後述の図\ref{fig:file_distribution}のようなピアとサーバがリンクでつながっている構造を考え，P2P構造とクライアントサーバ構造で，全てのピアへの送信にかかる時間を比較する．ここでサーバのアップロード速度を$u_s$，i番目のピアのアップロード速度を$d_i$，i番目のピアのダウンロード速度を$d_i$，ファイルの大きさを$F$，送信するピアの数を$N$とする．本文章では$N$個全てのピアがダウンロードするのにかかる時間を元にスケーラビリティを比較する．この時間を以降分配時間と呼ぶ．また，条件を公平にするために，仮定としてインターネットが十分な帯域を保持していると考え、サーバとクライアントが他のネットワークに参加していないと考える．
\begin{figure}[tb]
\includegraphics[width=10cm,pagebox=cropbox,clip]{FileDistribution.pdf}
 \caption{ピアとサーバがリンクでつながっている構造}
 \label{fig:file_distribution}
\end{figure}
まず，クライアントサーバ構造について分配時間を${D}_{cs}$と考える．サーバがピアへ送信することとピアが受信すること2つの面を考える．以降，データの容量の単位をbit，時間の単位を(hour)，送信速度を　(bit/hour)として考える．まず，前者について，送信するデータの総容量は$NF$であり，送信速度は前述の通り，$u_s$である．ゆえに，送信時間は$NF/u_s$で表される．続いて，後者については多数のピアの中で最短の受信速度は${d}_{min} = \min \{d_1 \sim d_N\}$であるため，受信時間は$F/{d}_{min}$で表される．これらより送信にかかる時間は前述の2側面のうち長い方なので
\begin{equation}
{D}_{cs}=\max \{ \frac{NF}{u_s}, \frac{F}{{d}_{min}} \}
\label{eq:cs}
\end{equation}
と表される．これより$N$が十分に大きいときに$N$の大きさに伴い線形に増加することがわかる．

続いて，P2P構造の分配時間を$D_p$と考える．サーバのピアへの送信にかかる時間，ピアの受信時間とシステム全体の送信能力から考える時間の3つの観点から考える．まず，1つ目の観点において，サーバは1度だけアクセスリンクに送信するので最短の送信にかかる時間は$F/u_s$である．また，2つ目の観点についてはサーバクライアント構造と同様に$F/{d}_{min}$である．最後の観点について，サーバとここのピアノ送信能力の和とシステム全体の送信能力は同等と考えられる．送信するデータの総容量は$NF$，送信速度は$u_s + \sum^{N}_{i=1}$ である．ゆえにこの観点からは少なくとも分配時間が$\frac{NF}{u_s + \sum^{N}_{i=1}}$と表される．故に分配時間が
\begin{equation}
D_p = \max \{ \frac{F}{u_s}, \frac{F}{{d}_{min}}, \frac{NF}{u_s + \sum^{N}_{i=1}} \}
\label{eq:p2p}
\end{equation}
と表される．

式(\ref{eq:cs})，(\ref{eq:p2p})より送信時間の比較を行う．ピアの送信速度を一律$u$ (bit/hour)，$F/u + 1$ (hour)，$u_s = 10u$，${d}_{min} \geqq u_s$とすると図
\ref{fig:graph}より常にP2Pの送信時間が短く，$N$がどんな値でもP2Pの送信時間が1時間未満であることがわかる．
\begin{figure}[tb]
\includegraphics[width=10cm,pagebox=cropbox,clip]{graph.pdf}
 \caption{クライアントサーバ構造とP2P構造の送信時間の比較}
 \label{fig:graph}
\end{figure}
\\
\subsubsection{BitTorrent}
続いてBitTorrentについて記述する．これはファイル分配における有名なP2Pプロトコルである．このプロトコルの名前になっているトレントというものはあるファイルの分配に参加している全てのピアの集合である．このトレント内のピアがファイルを分割したチャンクを受信し，ピアが受信すると同時にチャンクの送信も行う．ピアが全体のファイルを取得するとトレントを離脱する，またはトレントに残り他のピアにチャンクを送信する．また，トレント内のピアの特徴としていつでもトレントの離脱と加入が可能である．また，トレントがトラッカというノードを所持していることで，トラッカはトレントに加入したピアのIPアドレスを保持することで，トレント内のピアの存在の是非をトラッカに定期通知することでトレント内のピアの追跡を行うことができる．例えばAliceというピアを考慮すると，Aliceは他のピアと通信を行い，トラッカから通信に成功したピアノIPアドレスを取得する．このように通信に成功したピアを以降隣接ピアと呼ぶ．Aliceは隣接ピアの通信確立を繰り返し行い，隣接ピアが所持しているチャンクのリストを入手し，これを元に所持していないチャンクの要求をする．このチャンクの要求方法として，rarest firstとunchokedがある．前者は隣接ピアに存在する複製が少ない貴重なチャンクから要求を行う．隣接ピアの中でコピーされている回数が少ないものから貴重なチャンクを判断する．後者はデータの割合が高いペア(以下unchokedと示す)を4つ選択肢，この4つのピアに自身のチャンクを送信し，一定間隔ごとに新しい相手を探し，チャンクを送信を繰り返す．他のピアのunchokedの1つとなったらチャンクを取得できる．これによりトレント内のチャンクのコピーの個数が一定に近づく．
\\
\subsection{分散データベース}
\subsubsection{Distributed Hash Tables (DHT)}
続いてDHTについて述べる．これは(キー，値)のペアを持つ単純なデータベースでP2P構造は多数のピアにペアの一部を保存することでどのピアにも特定のキーで問い合わせや挿入が可能になるものである．ピアに
nbit表現でIDを割り振り，キーにも同じ範囲の整数でIDの割り振りを実施する．そしてキーを自身と最も近いIDを持つピアに格納をすることでペアを保存している．元々のキーが数字以外の場合はハッシュ化し，数値化を行う．ハッシュ化は7章で取り扱うため深くは述べないが，これに用いられるハッシュ関数は多対1関数であるため，出力が等しくなることがあるが，出力が同じ場合の入力の差は非常に少ないので同じものとみなすことができる．キーに自身と最も近いピアの選択を行うさい，全てのピアを探索するのは不可能である．本レポートでは円形DHTについて説明する．
\\
\subsubsection{円形DHT}
円形DHTとは図\ref{fig:circular_dht}のように円形に配置されたピアのことである．それぞれのピアは前後のピアの情報を保持し，ピアにキーの情報がないとき，次のピアを調査することで探索を行うものである．ピアが自由に参加離脱することから削除挿入において配列より計算が早いリストを利用しており，リストの途中の要素からたどり始めたとしても、リスト全体を一周することが容易であるため循環リストを利用し，突然の挿入削除に対して対応できる双方向型のリストを採用している．例えば図\ref{fig:circular_dht}のように[0,15]であるこの中に8つのピアが存在し，そのIDを1,3,4,5,8,10,12,15とする．今回，ピア3から探索をし，挿入するペアのキーが11とする．探索をID3,4,5,8,10,12の順に行う．今回は自身に続く最も近いピアを選択するという規則にすると，12のIDが割り振られたピアにペアを格納することとなる．この方式によりピアは2つの隣接ピアの情報のみ保持する．このため保持する情報を削減することができる．ただしこの方法には欠点があり，ノード数を$N$とすると最悪の場合$N$ノード全てに問い合わせを行い，平均で$N/2$ノードに問い合わせを行う必要がある．このように保持する隣接ピアの情報の個数と問い合わせの回数はトレードオフの関係にある．この問い合わせの回数を減らすために図\ref{fig:circular_dht_with_shortcuts}のようにショートカットを追加することが必要である．
\\
\begin{figure}[tb]
\includegraphics[width=10cm,pagebox=cropbox,clip]{CircularDHT.pdf}
 \caption{円形DHT}
 \label{fig:circular_dht}
\end{figure}

\begin{figure}[tb]
\includegraphics[width=10cm,pagebox=cropbox,clip]{CircularDHTWithShortcuts.pdf}
 \caption{ショートカット付き円形DHT}
 \label{fig:circular_dht_with_shortcuts}
\end{figure}

\subsubsection{ピアチャーン}
またP2Pにおいてピアがトレントから自由に参加や離脱が可能という点をDHTの設計において考慮が必要である．これをピアチャーンと呼ぶ．離脱時にその次にピアの情報を取得し，円形DHTを保持することである．例えば図\ref{fig:circular_dht}においてピア5が離れた時にピア4はピア8の情報を保持しているのでピア8にピア10の情報を請求し，ピア4の保持している情報に加える．これにより，ピアの自由な参加離脱に対応ができるようになる．
\\
\section{ソケットプログラミング}
ソケット API(Socket Application Programming Interface)は，アプリケーションに対して，異なるホスト間での通信をサポートするためのトランスポート層以下の機能を提供するプログラミングインタフェースで，クライアント/サーバモデルを実現するために用いられるものである．UDPとTCPにてソケットプログラミングを実施するため，それぞれについて確認する．これらはトランスポート層のプロトコルであり，前者はコネクションレスで信頼性がなく輻輳制御を行わないため容量が小さいプロトコルであり，後者はコネクション指向通信を行い，信頼性があり，輻輳制御を行うため容量が大きいプロトコルである．これらを用いたプログラムをPythonのプログラムを元に説明する．これは鍵ソケットの考えが明瞭であり，またJAVAやC,C++に記法が似ているのでプログラムが読みやすいという点を考慮した結果である．今回ソケットプログラミングを行う上でUDP，TCP共に\\
1. クライアントが一連の文字入力をサーバに送信　\\
2. サーバがサーバが受信した文字入力を大文字に変換 \\
3. サーバが変換後のデータをクライアントに送信\\
4. クライアントは受信データをスクリーンに表示　\\
の流れでプログラミングを行う.\\
\subsection{UDPソケットプログラミング}
UDPのクライアント，サーバプログラムはそれぞれUDPClient.py，UDPServer.pyで表される．UDPでは送信前にパケットに宛先アドレスを付加し，受信プロセスまでの道を決定する．その後パケット受信時にソケットから抽出を行い，内容を確認し適切な振る舞いを実施する．宛先アドレスの内部には目的地のIPアドレスとポート番号の情報が含まれている．IPアドレスだけで目的のホストに行くことが可能であるが，ホストは多数のネットワークプロセルを実行しているため，ホストが持つ複数のソケットを区別するために存在する．\\
\subsubsection{UDPクライアント}
UDPクライアントについてのコードは図\ref{fig:udp_client}のように示す．
\begin{figure}[tb]
\includegraphics[width=10cm]{UDPClient.png}
 \caption{UDPクライアントのコード}
 \label{fig:udp_client}
\end{figure}
1行目はsocketモジュールのインクルードを行い，2行目でサーバの名前の決定によりIPアドレスを設定している．3行目でポート番号を12000に指定し，4行目でソケット生成を行い，受信プロセスまでの道を決定している．続いて5行目で，プロンプトからの文字入力を変数message代入している．6行目ではメッセージ付パケットをクライアントソケットに送信し，7行目でパケット到着後データを modifiedMessage に格納し，ソースアドレスを serverAddressに格納している．8,9行目でスクリーンに表示しソケットを閉鎖している．\\
\subsubsection{UDPサーバ}
UDPサーバについてのコードは図\ref{fig:udp_server}のように示す．
\begin{figure}[tb]
\includegraphics[width=10cm]{UDPServer.png}
 \caption{UDPサーバのコード}
 \label{fig:udp_server}
\end{figure}
1,2,3行目はクライアントと同じ動作を行い，4行目でサーバのソケットにポート番号を対応させ，6行目でクライアントのパケットを待機させ，7行目でデータとソー8行目でメッセージを大文字に変換し9行目でアドレスからパケットをサーバのソケットに送信している．その後，インターネットがクライアントのアドレスに配達し，パケット送信後はサーバ側は他のUDPパケットを受信するまで待機状態を継続する．\\

\subsection{TCPソケットプログラミング}
TCPは先述の通りコネクション指向でデータ送信前にハンドシェイクとTCP接続を確立するものである．ハンドシェイクとは通信路確立後に通信規則を自動的に決定するものである．TCP接続にはクライアントとサーバのソケットのアドレスを利用する．TCP接続確立後はソケット経由でデータ送信を行う．UDPと同様に接触開始前にサーバのプロセスを先に実行し，データの送信はバイト単位で送信している．サーバプログラムは特別なソケットを保持していて，このソケットはクライアントの最初の接触を受け入れるためにある．これを別名歓迎用の扉と呼ぶ．TCPソケット生成時，クライアントは歓迎用の扉のアドレスを指定し，これを用いてデータをやりとり捨．これにより，接続を特定のクライアントに制限している．TCPソケット生成後3ウェイハンドシェイクを行う．これはTCP接続を確立後にトランスポート層で実行されるもので，クライアントはサーバの歓迎用の扉をノックし，サーバはノックを検知し，ノックしたクライアントのみを通す新しいソケットを生成する．つまり通信を行うクライアントごとに新しい扉の作成を行っている．\\

\subsubsection{TCPクライアント}
TCPクライアントについてのコードは図\ref{fig:tcp_client}のように示す．
\begin{figure}[tb]
\includegraphics[width=10cm]{TCPClient.png}
 \caption{TCPクライアントのコード}
 \label{fig:tcp_client}
\end{figure}
1から4行目,9行目,10行目はUDPクライアントとほぼ同じ動作で，5行目ではサーバのアドレスを指定し，TCP接続を開始し，5行目実行後3ウェイハンドシェイク6行目でsentenceに改行コードまでの文字列を代入している．7行目ではTCP接続にsentenceの文字列のバイトを送信する．この際，UDPと異なり，パケット背作成と宛先アドレスは必要がない．その後クライアントはサーバからのバイト返還を待機する．サーバがバイトを返還した後，modifiedSentenceにバイトの文字列を格納している．\\
\subsubsection{TCPサーバ}
TCPサーバについてのコードは図\ref{fig:tcp_server}のように示す．
\begin{figure}[tb]
\includegraphics[width=10cm]{TCPServer.png}
 \caption{TCPサーバのコード}
 \label{fig:tcp_server}
\end{figure}
1から4行目,6行目,9から11行目はUDPサーバとほぼ同じ動作で，5行目でクライアントからのTCP通信リクエストの受信を行う．5行目の関数の引数はリクエストを受け付けているキューの数である．
8行目でノックしたクライアントのみを通すソケットを作成し，その後3ウェイハンドシェイクを行いTCP接続を確立する．12行目で8行目に生成した通信用ソケットを閉鎖する．しかしserverSocketは開いたままで他のクライアントが文字を送信することが可能となっている．

\end{document}
